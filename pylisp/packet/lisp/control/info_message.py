'''
Created on 6 jan. 2013

@author: sander
'''
from bitstring import ConstBitStream, BitArray, Bits
from ipaddress import IPv4Network, IPv6Network
from pylisp.packet.lisp.control import type_registry, KEY_ID_HMAC_SHA_1_96, KEY_ID_HMAC_SHA_256_128, KEY_ID_NONE
from pylisp.packet.lisp.control.base import ControlMessage
from pylisp.utils.afi import read_afi_address_from_bitstream, get_bitstream_for_afi_address
from pylisp.utils.lcaf.nat_traversal_address import LCAFNATTraversalAddress
import hashlib
import hmac
import numbers


__all__ = ['InfoMessage']

# This implementation is based on http://tools.ietf.org/html/draft-ermagan-lisp-nat-traversal-03, which specifies that
# both the InfoRequest and InfoReply have message type 7, so we implement them as one message with two variants.


class InfoMessage(ControlMessage):
    # Class property: which message type do we represent?
    message_type = 7

    def __init__(self, is_reply=False, nonce='\x00\x00\x00\x00\x00\x00\x00\x00', key_id=0, authentication_data='',
                 ttl=0, eid_prefix=None, reply=None):
        '''
        Constructor
        '''
        super(InfoMessage, self).__init__()

        # Set defaults
        self.is_reply = is_reply
        self.nonce = nonce
        self.key_id = key_id
        self.authentication_data = authentication_data
        self.ttl = ttl
        self.eid_prefix = eid_prefix
        self.reply = reply

        # Store space for reserved bits
        self._reserved1 = BitArray(27)
        self._reserved2 = BitArray(8)

    def sanitize(self):
        '''
        Check if the current settings conform to the LISP specifications and
        fix them where possible.
        '''
        # We override the MapRegisterMessage sa
        super(InfoMessage, self).sanitize()

        # R: R bit indicates this is a reply to an Info-Request (Info-
        # Reply).  R bit is set to 0 in an Info-Request.  When R bit is set
        # to 0, the AFI field (following the EID-prefix field) must be set
        # to 0.  When R bit is set to 1, the packet contents follow the
        # format for an Info-Reply as described below.
        if not isinstance(self.is_reply, bool):
            raise ValueError('Is-reply flag must be a boolean')

        # Nonce: An 8-byte random value created by the sender of the Info-
        # Request.  This nonce will be returned in the Info-Reply.  The
        # nonce SHOULD be generated by a properly seeded pseudo-random (or
        # strong random) source.
        if len(bytes(self.nonce)) != 8:
            raise ValueError('Invalid nonce')

        # Key ID:  A configured ID to find the configured Message
        # Authentication Code (MAC) algorithm and key value used for the
        # authentication function.  See Section 14.4 for codepoint
        # assignments.
        if self.key_id not in (KEY_ID_NONE, KEY_ID_HMAC_SHA_1_96,
                               KEY_ID_HMAC_SHA_256_128):
            raise ValueError('Invalid Key ID')

        # Authentication Data:  The message digest used from the output of the
        # Message Authentication Code (MAC) algorithm.  The entire Map-
        # Register payload is authenticated with this field preset to 0.
        # After the MAC is computed, it is placed in this field.
        # Implementations of this specification MUST include support for
        # HMAC-SHA-1-96 [RFC2404] and support for HMAC-SHA-256-128 [RFC6234]
        # is RECOMMENDED.
        if not isinstance(self.authentication_data, bytes):
            raise ValueError('Invalid authentication data')

        # TTL: The time in minutes the recipient of the Info-Reply will
        # store the RTR Information.
        if not isinstance(self.ttl, numbers.Integral) \
        or self.ttl < 0 or self.ttl > 0xffffffff:
            raise ValueError('Invalid TTL')

        # EID-prefix:  4 octets if an IPv4 address-family, 16 octets if an IPv6
        # address-family.
        if not isinstance(self.eid_prefix, (IPv4Network, IPv6Network)):
            raise ValueError('EID prefix must be IPv4 or IPv6')

        # When a Map-Server receives an Info-Request message, it responds with
        # an Info-Reply message.  The Info-Reply message source port is 4342,
        # and destination port is taken from the source port of the triggering
        # Info-Request.  Map-Server fills the NAT LCAF (LCAF Type = 7) fields
        # according to their description.  The Map-Server uses AFI=0 for the
        # Private ETR RLOC Address field in the NAT LCAF.
        if self.is_reply:
            if not isinstance(self.reply, LCAFNATTraversalAddress):
                raise ValueError("An InfoMessage which is an Info-Reply must contain an LCAFNATTraversalAddress")
        else:
            if self.reply is not None:
                raise ValueError("An InfoMessage which is an Info-Request can not contain a reply")

    def calculate_authentication_data(self, key):
        '''
        Calculate the authentication data based on the current key-id and the
        given key.
        '''
        # This one is easy
        if self.key_id == KEY_ID_NONE:
            return ''

        # Determine the digestmod and how long the authentication data will be
        if self.key_id == KEY_ID_HMAC_SHA_1_96:
            digestmod = hashlib.sha1
            data_length = 20
        elif self.key_id == KEY_ID_HMAC_SHA_256_128:
            digestmod = hashlib.sha256
            data_length = 32
        else:
            raise ValueError('Unknown Key ID')

        # Fill the authentication data with the right number of zeroes
        # after storing the original first so we can restore it later
        current_authentication_data = self.authentication_data
        self.authentication_data = '\x00' * data_length

        # Build the packet
        msg = self.to_bytes()

        # Restore the authentication data
        self.authentication_data = current_authentication_data

        # Return the authentication data based on the generated packet
        # and the given key
        return hmac.new(key, msg, digestmod).digest()

    def verify_authentication_data(self, key):
        '''
        Verify the current authentication data based on the current key-id and
        the given key.
        '''
        correct_authentication_data = self.calculate_authentication_data(key)
        return self.authentication_data == correct_authentication_data

    def insert_authentication_data(self, key):
        '''
        Insert authentication data based on the current key-id and the given
        key.
        '''
        correct_authentication_data = self.calculate_authentication_data(key)
        self.authentication_data = correct_authentication_data

    @classmethod
    def from_bytes(cls, bitstream):
        '''
        Parse the given packet and update properties accordingly
        '''
        packet = cls()

        # Convert to ConstBitStream (if not already provided)
        if not isinstance(bitstream, ConstBitStream):
            if isinstance(bitstream, Bits):
                bitstream = ConstBitStream(auto=bitstream)
            else:
                bitstream = ConstBitStream(bytes=bitstream)

        # Read the type
        type_nr = bitstream.read('uint:4')
        if type_nr != packet.message_type:
            msg = 'Invalid bitstream for a {0} packet'
            class_name = packet.__class__.__name__
            raise ValueError(msg.format(class_name))

        # Read if this is a reply
        packet.is_reply = bitstream.read('bool')

        # Skip reserved bits
        packet._reserved1 = bitstream.read(27)

        # Read the nonce
        packet.nonce = bitstream.read('bytes:8')

        # Read the key id
        packet.key_id = bitstream.read('uint:16')

        # Read the authentication data
        data_length = bitstream.read('uint:16')
        packet.authentication_data = bitstream.read('bytes:%d' % data_length)

        # Read the TTL
        packet.ttl = bitstream.read('uint:32')

        # Skip reserved bits
        packet._reserved2 = bitstream.read(8)

        # Store the EID prefix mask length until we need it
        eid_prefix_len = bitstream.read('uint:8')

        # Read the EID prefix
        packet.eid_prefix = read_afi_address_from_bitstream(bitstream, eid_prefix_len)

        # Read the reply
        packet.reply = read_afi_address_from_bitstream(bitstream)

        # Verify that the properties make sense
        packet.sanitize()

        return packet

    def to_bytes(self):
        '''
        Create bytes from properties
        '''
        # Verify that properties make sense
        self.sanitize()

        # Start with the type
        bitstream = BitArray('uint:4=%d' % self.message_type)

        # Add the flags
        bitstream += BitArray('bool=%d' % self.is_reply)

        # Add reserved bits
        bitstream += self._reserved1

        # Add the nonce
        bitstream += BitArray(bytes=self.nonce)

        # Add the key-id and authentication data
        bitstream += BitArray('uint:16=%d, uint:16=%d, hex=%s'
                              % (self.key_id,
                                 len(self.authentication_data),
                                 self.authentication_data.encode('hex')))

        # Add the TTL
        bitstream += BitArray('uint:32=%d' % self.ttl)

        # Add reserved bits
        bitstream += self._reserved2

        # Add the EID prefix mask length
        bitstream += BitArray('uint:8=%d' % self.eid_prefix.prefixlen)

        # Add the EID prefix
        bitstream += get_bitstream_for_afi_address(self.eid_prefix)

        # Add the reply
        bitstream += get_bitstream_for_afi_address(self.reply)

        return bitstream.bytes


# Register this class in the registry
type_registry.register_type_class(InfoMessage)
