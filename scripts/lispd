#!/usr/bin/env python
# encoding: utf-8
"""
LISPd manages all LISP control packets sent and received by
a system. By default it listens on UDP port 4342, dispatches
incoming requests to the configurable modules and can send
requests to other systems on behalf of other applications.
"""

from argparse import ArgumentParser, RawDescriptionHelpFormatter
from ipaddress import ip_address, IPv4Address
from multiprocessing.dummy import Pool
from pylisp.application.lispd import settings
from pylisp.application.lispd.message_handler import handle_message
from pylisp.application.lispd.received_message import ReceivedMessage
from pylisp.application.lispd.settings import ConfigurationError
from pylisp.packet.lisp.control import ControlMessage
from pylisp.utils.task_thread import TaskThread
import logging
import select
import socket
import sys


logger = logging.root


def create_sockets(config):
    sockets = []
    for sockaddr in config.LISTEN_ON:
        # (re)parse the address
        address = ip_address(sockaddr[0])

        logger.info("Binding to %s port %d" % (address, sockaddr[1]))

        # Determine the address family
        if isinstance(address, IPv4Address):
            family = socket.AF_INET
        else:
            family = socket.AF_INET6

        # In case we got passed an IPv[46]Address in the sockaddr
        plain_sockaddr = list(sockaddr)
        plain_sockaddr[0] = str(plain_sockaddr[0])
        plain_sockaddr = tuple(plain_sockaddr)

        # Create the socket and bind to it
        sock = socket.socket(family, socket.SOCK_DGRAM, socket.SOL_UDP)
        sock.bind(plain_sockaddr)
        sockets.append(sock)

    return sockets


class BackgroundProcessingTask(TaskThread):
    def __init__(self, config, my_sockets):
        super(BackgroundProcessingTask, self).__init__(interval=10)
        self.config = config
        self.my_sockets = my_sockets

    def task(self):
        logger.debug("Running background processing")
        with self.config.lock:
            for instance in self.config.INSTANCES:
                for afi in self.config.INSTANCES[instance]:
                    self.config.INSTANCES[instance][afi].process(self.my_sockets)
        logger.debug("Finished background processing")


def main(argv=None):
    """Command line options."""

    if argv is None:
        argv = sys.argv
    else:
        sys.argv.extend(argv)

    try:
        # Setup argument parser
        parser = ArgumentParser(description=__doc__,
                                formatter_class=RawDescriptionHelpFormatter)
        parser.add_argument("-v",
                            "--verbose",
                            dest="verbose",
                            action="store_true",
                            help="be verbose")
        parser.add_argument("-d",
                            "--debug",
                            dest="debug",
                            action="store_true",
                            help="show debugging output")
        parser.add_argument("-C",
                            "--show-config",
                            dest="show_config",
                            action="store_true",
                            help="show the configuration and exit")

        # Process arguments
        args = parser.parse_args()

        # Configure the logging process
        if args.debug:
            logging_level = logging.DEBUG
        elif args.verbose:
            logging_level = logging.INFO
        else:
            logging_level = logging.WARNING

        logging.basicConfig(level=logging_level,
                            format='%(asctime)s [%(module)s %(levelname)s] %(message)s')

        # Init the settings
        settings.config = settings.Settings()

        # Show config?
        if args.show_config:
            for setting, value in settings.config.__dict__.iteritems():
                if setting == setting.upper():
                    # Show the setting
                    sys.stdout.write("%s=%r\n" % (setting, value))
            return 2

        # Determine local sockets
        sockets = create_sockets(settings.config)

        # Create the thread pool
        pool = Pool(processes=settings.config.THREAD_POOL_SIZE)

        # Create the timer for processing
        processing_timer = BackgroundProcessingTask(settings.config, sockets)
        processing_timer.start()

        logger.info("Waiting for incoming messages to process")
        while True:
            try:
                # Get the active sockets
                rlist, dummy, dummy = select.select(sockets, [], [])

                for sock in rlist:
                    data, addr = sock.recvfrom(65536)
                    logger.debug("Received %d bytes from %r", len(data), addr)

                    # Parse input
                    try:
                        message = ControlMessage.from_bytes(data)
                        received_message = ReceivedMessage(message=message, source=addr, socket=sock)
                    except Exception, e:
                        logger.error("Error in message from %r: %s", addr, e)

                    # Dispatch
                    try:
                        kwds = {'received_message': received_message,
                                'my_sockets': sockets}
                        pool.apply_async(handle_message, kwds=kwds)
                    except Exception, e:
                        logger.error("Uncaught exception when handling message from %r: %s", addr, e)

            except KeyboardInterrupt:
                logger.info("Interupted")
                break
            except Exception, e:
                logger.error("Unexpected exception: %s" % e)

        logger.info("Shutting down")

        # Wait for the workers
        processing_timer.shutdown()
        pool.close()
        pool.join()

        logger.info("LISPd shut down")

        return 0
    except KeyboardInterrupt:
        ### handle keyboard interrupt ###
        return 0
    except ConfigurationError:
        return 1
    except Exception, e:
        logger.exception("Unexpected exception")
        return 2


if __name__ == "__main__":
    sys.exit(main())
